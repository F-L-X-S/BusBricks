\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{class_comm_interface}{Comm\+Interface$<$ interface\+\_\+type $>$}} \\*Template for generic communication-\/interface specifies a standardized interface to use for integrating any hardware-\/interface (e.\+g. Software\+Serial, One\+Wire...) into a Service-\/\+Interface The template ensures the correct handling of send-\/ and receive-\/buffers of the interface\+: }{\pageref{class_comm_interface}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_comm_interface__modbus_r_t_u}{Comm\+Interface\+\_\+modbus\+RTU}} \\*The Modbus-\/\+RTU Comm\+Interface-\/class specifies a communication interface with Software\+Serial as interface-\/type and Monitors modbus-\/specific timeouts. Ensures correct data-\/transfer between standardized Frame-\/\+Objects in the Interface-\/\+Stack and Software\+Serial }{\pageref{class_comm_interface__modbus_r_t_u}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_comm_interface_base}{Comm\+Interface\+Base}} \\*Communcation-\/\+Interface-\/\+Base-\/\+Class containing functions, that have to be re-\/implemented in the derived classes of the Comm\+Interface-\/template but which have to be called in other (abstract) classes (e.\+g. \doxylink{class_service_interface}{Service\+Interface}) }{\pageref{class_comm_interface_base}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_content}{Content$<$ content\+\_\+type, representation\+\_\+type $>$}} \\*The cascading of processing information and the rules applied to it lead to the concept of content-\/ and representation. In every iteration, an information is processed and the rules of the next level, closer to the physical layer are applied to it, the information closer to the format the service is able to process is called \doxylink{class_content}{Content}. Conversely, the format, the information has after applying the rules of the next level closer to "{}\+Layer-\/0"{} is called representation }{\pageref{class_content}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_content__stack}{Content\+\_\+stack$<$ content\+\_\+class, Max\+Size $>$}} \\*Content-\/\+Stack-\/\+Template the content-\/stack stores the added items (call-\/by-\/value / copy) on internal array the item added last is stacked on top (highest index), the one added first is stored on index "{}0"{} }{\pageref{class_content__stack}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_frame}{Frame}} \\*Frame-\/\+Class as derived class from \doxylink{class_content}{Content} The derived classes define\+: -\/the conversion from a given payload plus protocol-\/specific parameters (e.\+g. Modbus-\/function-\/code, addresses...) to the frame-\/representation (override of content\+\_\+to\+\_\+rep from Content-\/\+Class) }{\pageref{class_frame}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_frame__modbus_r_t_u}{Frame\+\_\+modbus\+RTU}} \\*Class for defining the structure of the Modbus-\/\+RTU-\/\+Frame. Can be constructed by a given modbus-\/frame and extracts payload, device-\/id and function-\/code (additionally checking CRC) or by providing payload, device-\/id and function-\/code (additionally calculating CRC) }{\pageref{class_frame__modbus_r_t_u}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_message}{Message}} \\*Represents a message with information for sender and receiver, and provides methods for converting between PDU and message content }{\pageref{class_message}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_message__content__t}{Message\+\_\+content\+\_\+t}} \\*Represents the content of a message with sender and receiver information }{\pageref{struct_message__content__t}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_message__service}{Message\+\_\+service}} \\*\doxylink{class_service}{Service} class for handling messages and acknowledgments }{\pageref{class_message__service}}{}
\item\contentsline{section}{\mbox{\hyperlink{classarduino_mocking_1_1_mock_serial}{arduino\+Mocking\+::\+Mock\+Serial}} }{\pageref{classarduino_mocking_1_1_mock_serial}}{}
\item\contentsline{section}{\mbox{\hyperlink{classarduino_mocking_1_1_mock_time}{arduino\+Mocking\+::\+Mock\+Time}} }{\pageref{classarduino_mocking_1_1_mock_time}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_service}{Service$<$ content\+\_\+class, stack\+Size $>$}} \\*Service-\/\+Template to derive a \doxylink{class_service}{Service} class by defining the \doxylink{class_content}{Content} (derived Class of "{}\+Content"{}) to handle and the size of the stacks (send and receive). A \doxylink{class_service}{Service} has to be instantiated with a unique service-\/\+ID and an instance-\/\+ID, the service-\/instance should use for it\textquotesingle{}s communication. E.\+g.\+: Messenger-\/service with service-\/id "{}m"{} (specified in derived class, same on every host) is instantiated with a host-\/specific ID to identify the instances. The derived classes have to define the stack-\/processing to handle the payload at the rec-\/stack and add payload to the send-\/stack. Each derived class has a unique service\+ID to identify the Service-\/type and each instance in the communication-\/network has a unique instance\+ID }{\pageref{class_service}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_service_base}{Service\+Base}} \\*Service-\/base-\/class to add class-\/functions to vtable }{\pageref{class_service_base}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_service_cluster}{Service\+Cluster$<$ number\+\_\+of\+\_\+services $>$}} \\*The \doxylink{class_service_cluster}{Service\+Cluster} provides functions to manage multiple services. The \doxylink{class_service_cluster}{Service\+Cluster} is added to the \doxylink{class_service_interface}{Service\+Interface} and contains references to all services, associated with the interface }{\pageref{class_service_cluster}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_service_cluster_base}{Service\+Cluster\+Base}} \\*Service\+Cluster-\/base-\/class to add class-\/functions to vtable }{\pageref{class_service_cluster_base}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_service_interface}{Service\+Interface$<$ Comm\+Interface\+Base, frame\+Type $>$}} \\*Template for generic Service-\/\+Interface Defines the handling of incoming frames from \doxylink{class_comm_interface}{Comm\+Interface} to services stored in the associated \doxylink{class_service_cluster}{Service\+Cluster} and the conversion from PDU provided by Services in the \doxylink{class_service_cluster}{Service\+Cluster} to frames, getting sent by the communication-\/interface }{\pageref{class_service_interface}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_service_interface__modbus_r_t_u}{Service\+Interface\+\_\+modbus\+RTU}} \\*Service-\/\+Interface-\/class for Modbus-\/\+RTU\+: Impart incoming frames from the \doxylink{class_comm_interface}{Comm\+Interface} to the designated service of the service-\/cluster. Build outgoing modbus-\/\+RTU-\/frames from the payload provided by the services and impart them to the Communication-\/\+Interface. The service-\/\+IDs of the associated services are mapped to the modbus-\/rtu-\/function-\/code. If a \doxylink{class_frame}{Frame} is sent by a modbus-\/slave device, the frame\textquotesingle{}s slave-\/id is the same as the sender-\/id (and the local device-\/id). If a \doxylink{class_frame}{Frame} is sent by a modbus-\/device in mastermode, the frame\textquotesingle{}s slave-\/id is the receiver-\/id provided by the service, that provided the payload for the frame }{\pageref{class_service_interface__modbus_r_t_u}}{}
\item\contentsline{section}{\mbox{\hyperlink{classarduino_mocking_1_1_software_serial}{arduino\+Mocking\+::\+Software\+Serial}} }{\pageref{classarduino_mocking_1_1_software_serial}}{}
\end{DoxyCompactList}
