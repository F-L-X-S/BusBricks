\doxysection{Service\+Interface\texorpdfstring{$<$}{<} Comm\+Interface\+Base, frame\+Type \texorpdfstring{$>$}{>} Class Template Reference}
\hypertarget{class_service_interface}{}\label{class_service_interface}\index{ServiceInterface$<$ CommInterfaceBase, frameType $>$@{ServiceInterface$<$ CommInterfaceBase, frameType $>$}}


Template for generic Service-\/\+Interface Defines the handling of incoming frames from \doxylink{class_comm_interface}{Comm\+Interface} to services stored in the associated \doxylink{class_service_cluster}{Service\+Cluster} and the conversion from PDU provided by Services in the \doxylink{class_service_cluster}{Service\+Cluster} to frames, getting sent by the communication-\/interface.  




{\ttfamily \#include $<$Service\+Interface.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_service_interface_acc70c85786fa2e133f90683f60ebf67f}{Service\+Interface}} (\mbox{\hyperlink{class_comm_interface_base}{Comm\+Interface\+Base}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{class_service_interface_a899b6f3e042682b285dca2588b833ae6}{comm\+\_\+interface}}, \mbox{\hyperlink{class_service_cluster_base}{Service\+Cluster\+Base}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{class_service_interface_ad1f915c1a536af5c73aa1315fd035535}{services}})
\begin{DoxyCompactList}\small\item\em Construct a new \doxylink{class_service}{Service} Interface object. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_service_interface_aeaebdad7101c0a66bee56edc4e6a19c1}{communicate}} ()=0
\begin{DoxyCompactList}\small\item\em Execute all relevant tasks for transferring data between \doxylink{class_comm_interface}{Comm\+Interface} and Services\+: Getting payloads to sent from the Services, adding received payloads to the right Services, Updating communication-\/stacks, Executing the Comm\+Interfaces send-\/ and receive-\/cycle (Has to be implemented in the derived class) \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{class_service_interface_ab4112c2b2eb29d1e0ade95e4f3c07030}\label{class_service_interface_ab4112c2b2eb29d1e0ade95e4f3c07030} 
virtual void {\bfseries get\+PDU\+\_\+from\+\_\+services} ()=0
\begin{DoxyCompactList}\small\item\em Add all PDUs provided by the services to the sendstack, depending on how frametype stores the information, which service the payload is designated for (Implemented in derived Class) \end{DoxyCompactList}\item 
\Hypertarget{class_service_interface_ac740850d1a24a1d8a96f7a7bbf4eb784}\label{class_service_interface_ac740850d1a24a1d8a96f7a7bbf4eb784} 
virtual void {\bfseries add\+PDU\+\_\+to\+\_\+services} ()=0
\begin{DoxyCompactList}\small\item\em Impart all received PDUs from the receivestack to the associated services, depending on how frametype stores the information, which service the payload is designated for (Implemented in derived Class) \end{DoxyCompactList}\item 
\Hypertarget{class_service_interface_a4dffc7c3e366b470e1075db65333b67e}\label{class_service_interface_a4dffc7c3e366b470e1075db65333b67e} 
virtual void {\bfseries process\+Services} ()
\begin{DoxyCompactList}\small\item\em start the stack\+Processing of the registered services \end{DoxyCompactList}\item 
\Hypertarget{class_service_interface_a23feb243ed1748e04dd757aa5f788b3e}\label{class_service_interface_a23feb243ed1748e04dd757aa5f788b3e} 
virtual void {\bfseries process\+Send\+Stack} ()
\begin{DoxyCompactList}\small\item\em Send all Frames, stored in the send\+Stack. As long as the send\+Stack is not empty, the function is getting pointers to the representation of the \doxylink{class_frame}{Frame} on the bottom of the stack. The pointer to the string-\/formatted representation is imparted to the \doxylink{class_comm_interface}{Comm\+Interface} as teh next frame to be sent by calling send\+New\+Frame. Then the \doxylink{class_comm_interface}{Comm\+Interface}\textquotesingle{}s send\+Cycle get\textquotesingle{}s executed. Exit, after the send\+Stack is empty. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_service_interface_a7c5ec5e13af8a67d1b08c963fcd71214}{process\+Rec\+Stack}} ()
\begin{DoxyCompactList}\small\item\em Add items received by the \doxylink{class_comm_interface}{Comm\+Interface} to the rec\+Stack and execute the \doxylink{class_comm_interface}{Comm\+Interface}\textquotesingle{}s receive\+Cycle to wait for new incoming frames. Exit, if the rec\+Stack is full or the \doxylink{class_comm_interface}{Comm\+Interface} did not received new Frames within the in receive\+Cycle specified timeout. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{class_service_interface_a899b6f3e042682b285dca2588b833ae6}\label{class_service_interface_a899b6f3e042682b285dca2588b833ae6} 
\mbox{\hyperlink{class_comm_interface_base}{Comm\+Interface\+Base}} \texorpdfstring{$\ast$}{*} {\bfseries comm\+\_\+interface}
\begin{DoxyCompactList}\small\item\em pointer to Communication-\/\+Interface (instance of Comm\+Interface-\/derived class) \end{DoxyCompactList}\item 
\Hypertarget{class_service_interface_ad1f915c1a536af5c73aa1315fd035535}\label{class_service_interface_ad1f915c1a536af5c73aa1315fd035535} 
\mbox{\hyperlink{class_service_cluster_base}{Service\+Cluster\+Base}} \texorpdfstring{$\ast$}{*} {\bfseries services}
\begin{DoxyCompactList}\small\item\em pointer to \doxylink{class_service_cluster}{Service\+Cluster}, containing the Services associated with the Interface (instance of Service\+Cluster-\/derived class) ~\newline
 \end{DoxyCompactList}\item 
\Hypertarget{class_service_interface_a7793efd070a56f021ce56a372b13c2fa}\label{class_service_interface_a7793efd070a56f021ce56a372b13c2fa} 
\mbox{\hyperlink{class_content__stack}{Content\+\_\+stack}}$<$ frame\+Type, STACKSIZE $>$ {\bfseries rec\+Stack}
\begin{DoxyCompactList}\small\item\em stack for received frames (instance of Content\+\_\+stack-\/derived class, specified for type of frames, the bus is using) ~\newline
 \end{DoxyCompactList}\item 
\Hypertarget{class_service_interface_a38bd169d6286c4ddbda050b7f28d093a}\label{class_service_interface_a38bd169d6286c4ddbda050b7f28d093a} 
\mbox{\hyperlink{class_content__stack}{Content\+\_\+stack}}$<$ frame\+Type, STACKSIZE $>$ {\bfseries send\+Stack}
\begin{DoxyCompactList}\small\item\em stack for frames to send next (instance of Content\+\_\+stack-\/derived class, specified for type of frames, the bus is using) ~\newline
 \end{DoxyCompactList}\item 
\Hypertarget{class_service_interface_a1e08cf764cea2084e1f425e32f44d2c1}\label{class_service_interface_a1e08cf764cea2084e1f425e32f44d2c1} 
\mbox{\hyperlink{namespacearduino_mocking_a074bce778184555fd29d1370a36298bf}{String}} {\bfseries send\+Item}
\begin{DoxyCompactList}\small\item\em Item to be sent next ~\newline
 \end{DoxyCompactList}\item 
\Hypertarget{class_service_interface_ac69502c2d78c4a046c5d3219d637f1b3}\label{class_service_interface_ac69502c2d78c4a046c5d3219d637f1b3} 
\mbox{\hyperlink{namespacearduino_mocking_a074bce778184555fd29d1370a36298bf}{String}} {\bfseries rec\+Item}
\begin{DoxyCompactList}\small\item\em Item received last ~\newline
 \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename \mbox{\hyperlink{class_comm_interface_base}{Comm\+Interface\+Base}}, typename frame\+Type$>$\newline
class Service\+Interface$<$ Comm\+Interface\+Base, frame\+Type $>$}
Template for generic Service-\/\+Interface Defines the handling of incoming frames from \doxylink{class_comm_interface}{Comm\+Interface} to services stored in the associated \doxylink{class_service_cluster}{Service\+Cluster} and the conversion from PDU provided by Services in the \doxylink{class_service_cluster}{Service\+Cluster} to frames, getting sent by the communication-\/interface. 


\begin{DoxyTemplParams}{Template Parameters}
{\em \doxylink{class_comm_interface_base}{Comm\+Interface\+Base}} & type of \doxylink{class_comm_interface}{Comm\+Interface} to use, derived Class of the abstract Comm\+Interface-\/\+Class (e.\+g. \doxylink{class_comm_interface__modbus_r_t_u}{Comm\+Interface\+\_\+modbus\+RTU}) \\
\hline
{\em frame\+Type} & type of the frames to be send, derived Class of the abstract Frame-\/\+Class (e.\+g. \doxylink{class_frame__modbus_r_t_u}{Frame\+\_\+modbus\+RTU}) \\
\hline
\end{DoxyTemplParams}


\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{class_service_interface_acc70c85786fa2e133f90683f60ebf67f}\index{ServiceInterface$<$ CommInterfaceBase, frameType $>$@{ServiceInterface$<$ CommInterfaceBase, frameType $>$}!ServiceInterface@{ServiceInterface}}
\index{ServiceInterface@{ServiceInterface}!ServiceInterface$<$ CommInterfaceBase, frameType $>$@{ServiceInterface$<$ CommInterfaceBase, frameType $>$}}
\doxysubsubsection{\texorpdfstring{ServiceInterface()}{ServiceInterface()}}
{\footnotesize\ttfamily \label{class_service_interface_acc70c85786fa2e133f90683f60ebf67f} 
template$<$typename \mbox{\hyperlink{class_comm_interface_base}{Comm\+Interface\+Base}} , typename frame\+Type $>$ \\
\mbox{\hyperlink{class_service_interface}{Service\+Interface}}$<$ \mbox{\hyperlink{class_comm_interface_base}{Comm\+Interface\+Base}}, frame\+Type $>$\mbox{\hyperlink{class_service_interface}{\+::\+Service\+Interface}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_comm_interface_base}{Comm\+Interface\+Base}} \texorpdfstring{$\ast$}{*}}]{comm\+\_\+interface}{, }\item[{\mbox{\hyperlink{class_service_cluster_base}{Service\+Cluster\+Base}} \texorpdfstring{$\ast$}{*}}]{services}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Construct a new \doxylink{class_service}{Service} Interface object. 


\begin{DoxyParams}{Parameters}
{\em comm\+\_\+interface} & pointer to an instance of a Comm\+Interface-\/derived class-\/object \\
\hline
{\em services} & pointer to an instance of a Service\+Cluster-\/derived class-\/object containing the associated services \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\Hypertarget{class_service_interface_aeaebdad7101c0a66bee56edc4e6a19c1}\index{ServiceInterface$<$ CommInterfaceBase, frameType $>$@{ServiceInterface$<$ CommInterfaceBase, frameType $>$}!communicate@{communicate}}
\index{communicate@{communicate}!ServiceInterface$<$ CommInterfaceBase, frameType $>$@{ServiceInterface$<$ CommInterfaceBase, frameType $>$}}
\doxysubsubsection{\texorpdfstring{communicate()}{communicate()}}
{\footnotesize\ttfamily \label{class_service_interface_aeaebdad7101c0a66bee56edc4e6a19c1} 
template$<$typename \mbox{\hyperlink{class_comm_interface_base}{Comm\+Interface\+Base}} , typename frame\+Type $>$ \\
virtual void \mbox{\hyperlink{class_service_interface}{Service\+Interface}}$<$ \mbox{\hyperlink{class_comm_interface_base}{Comm\+Interface\+Base}}, frame\+Type $>$\+::communicate (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Execute all relevant tasks for transferring data between \doxylink{class_comm_interface}{Comm\+Interface} and Services\+: Getting payloads to sent from the Services, adding received payloads to the right Services, Updating communication-\/stacks, Executing the Comm\+Interfaces send-\/ and receive-\/cycle (Has to be implemented in the derived class) 



Implemented in \mbox{\hyperlink{class_service_interface__modbus_r_t_u_ad1afd9540b980f8d4d8f2c947ce10a65}{Service\+Interface\+\_\+modbus\+RTU}}.

\Hypertarget{class_service_interface_a7c5ec5e13af8a67d1b08c963fcd71214}\index{ServiceInterface$<$ CommInterfaceBase, frameType $>$@{ServiceInterface$<$ CommInterfaceBase, frameType $>$}!processRecStack@{processRecStack}}
\index{processRecStack@{processRecStack}!ServiceInterface$<$ CommInterfaceBase, frameType $>$@{ServiceInterface$<$ CommInterfaceBase, frameType $>$}}
\doxysubsubsection{\texorpdfstring{processRecStack()}{processRecStack()}}
{\footnotesize\ttfamily \label{class_service_interface_a7c5ec5e13af8a67d1b08c963fcd71214} 
template$<$typename \mbox{\hyperlink{class_comm_interface_base}{Comm\+Interface\+Base}} , typename frame\+Type $>$ \\
virtual void \mbox{\hyperlink{class_service_interface}{Service\+Interface}}$<$ \mbox{\hyperlink{class_comm_interface_base}{Comm\+Interface\+Base}}, frame\+Type $>$\+::process\+Rec\+Stack (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Add items received by the \doxylink{class_comm_interface}{Comm\+Interface} to the rec\+Stack and execute the \doxylink{class_comm_interface}{Comm\+Interface}\textquotesingle{}s receive\+Cycle to wait for new incoming frames. Exit, if the rec\+Stack is full or the \doxylink{class_comm_interface}{Comm\+Interface} did not received new Frames within the in receive\+Cycle specified timeout. 

If the \doxylink{class_comm_interface}{Comm\+Interface} received a new frame (that means, it\textquotesingle{}s rec\+Buffer is set to nullptr), the function creates the Frame-\/instance (specified by frame\+Type) from it\textquotesingle{}s rec\+Item and adds it to the rec\+Stack. Then it initializes the rec\+Item and imparts it\textquotesingle{}s reference to the comm\+\_\+interface by calling get\+Received\+Frame. The \doxylink{class_comm_interface}{Comm\+Interface} is now storing the next \doxylink{class_frame}{Frame} received at this address. After specifying the destination for received frames for Com\+Interface, the receive\+Cycle is executed again, to wait for incoming Frames. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/\+Users/felixschulke/\+Developement/\+Arduino/\+Modbus\+\_\+\+RTU/\+Modbus\+\_\+\+RTU/\+Modbus-\/\+RTU/lib/\+Interface/\mbox{\hyperlink{_service_interface_8h}{Service\+Interface.\+h}}\end{DoxyCompactItemize}
